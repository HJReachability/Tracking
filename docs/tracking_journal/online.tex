% !TEX root = tracking.tex
\section{Online Computation \label{sec:online}}
Algorithm \ref{alg:algOnline} describes the online computation. The inputs are the tracking error function $\valfunc(\rstate,T)$ for finite time horizon (or $\valfunc_\infty(\rstate)$ for infinite time horizon), and the gradient $\deriv$ from which the safety controller is obtained. 
Note that when discretized on a computer these functions will be look-up tables.

Lines \ref{ln:Istart}-\ref{ln:Iend} initialize the computation by setting the planning and tracking model states such that the relative system state is inside the TEB $\TEB_\estate$ (or $\TEB_{\estate, \infty}$). 
The TEB in the planning frame of reference is then computed using \eqref{eq:TEBp}. 

\begin{algorithm}	
	\caption{Online Trajectory Planning}
	\label{alg:algOnline}
	\begin{algorithmic}[1]
		%\STATE Inputs: tracking error function $\valfunc(\rstate)$, safety control function $\deriv(\rstate)$
		\STATE \textbf{Initialization}: \label{ln:Istart}
 		\STATE Initialize $\TEB(0)$ (finite time horizon) or $\TEB_\infty$ (infinite time horizon) from \eqref{eq:TEBp}. 
		\STATE Choose $\pstate, \tstate$ such that $\rstate \in  \TEB_\estate(0)$ (or $\rstate\in\TEB_{\estate,\infty}$).
    \STATE Set initial time: $\tvar \leftarrow 0$. \label{ln:Iend}
		\WHILE{Planning goal is not reached OR planning horizon is exceeded}
		\STATE \textbf{TEB Block}: \label{ln:obsStart}
		\STATE $\constrAug \leftarrow \constrSense \ominus \TEB_\estate(\tvar)$ (or $\TEB_{\estate, \infty}$)\label{ln:obsEnd}
		
		\STATE \textbf{Path Planner Block}:\label{ln:plannerStart}
		\STATE $\pstate_\text{next} \leftarrow \plannerfunc(\pstate, \constrAug)$\label{ln:plannerEnd}
		
		\STATE \textbf{Hybrid Tracking Controller Block}:\label{ln:controllerStart}
		\STATE $\rstate_\text{next} = \tstate - \ptmat\pstate_\text{next}$
		
		\IF{$\rstate_\text{next}$ is on boundary $\TEB_\estate(\tvar)$ (or $\TEB_{\estate, \infty}$)} 
		\STATE {use safety controller: $\tctrl \leftarrow \tctrl^*$ in \eqref{eq:opt_ctrl}}
		\ELSE \STATE{use performance controller: } 
          \STATE{$\tctrl \leftarrow$ desired controller} \ENDIF \label{ln:controllerEnd}
		
		\STATE \textbf{Tracking Model Block}: \label{ln:trackingStart}
		\STATE apply control $\tctrl$ to vehicle for a time step of $\dt$, which brings the vehicle to the state $\tstate_\text{next}$ \label{ln:trackingEnd}
		
		\STATE \textbf{Planning Model Block}:\label{ln:planningStart}
		\STATE update planning state $\pstate \leftarrow \pstate_\text{next}$
		\STATE check if $\pstate$ is at planning goal \label{ln:planningEnd}
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}
The TEB block is shown on lines \ref{ln:obsStart}-\ref{ln:obsEnd}. 
The sensor detects obstacles, or in general constraints, $\constrSense$ within the sensing region around the vehicle.
Note that constraints are defined in the state space of the planning system, and therefore can represent constraints not only in position but also in, for example, velocity or angular space.
The sensed constraints are augmented by $\TEB_\estate(\tvar)$ (or $\TEB_{\estate, \infty}$) using the Minkowski difference. 
This is done to ensure that no unsafe path or trajectory can be generated\footnote{The minimum allowable sensing distance is $\senseDist = 2\TEB_\estate(0) + \dx$, where $\dx$ is the largest step in space that the planner can make in one time step.}.

The path planner block (lines \ref{ln:plannerStart}-\ref{ln:plannerEnd}) takes in the planning model state $\pstate$ and the augmented constraints $\constrAug$, and outputs the next state of the planning system $\pstate_{next}$ through the function $\plannerfunc(\cdot, \cdot)$.
As mentioned, FaSTrack is agnostic to the planning algorithm used, so we assume that $\plannerfunc(\cdot, \cdot)$ has been provided.
The hybrid tracking controller block (lines \ref{ln:controllerStart}-\ref{ln:controllerEnd}) first computes the updated relative system state $\rstate_\text{next}$. 
If the $\rstate_\text{next}$ is on the boundary of the TEB $\TEB_\estate(0)$ (or $\TEB_{\estate, \infty}$), the safety controller given in \eqref{eq:opt_ctrl} must be used to remain within the TEB. 

If the relative system state is not on the tracking boundary, a performance controller may be used. For the example in Section \ref{sec:results} the safety and performance controllers are identical, but in general this performance controller can suit the needs of the individual applications.

The control $\tctrl^*$ is then applied to the physical system in the tracking block (lines \ref{ln:trackingStart}-\ref{ln:trackingEnd}) for a time period of $\dt$. 
The next state is denoted $\tstate_\text{next}$. 
Finally, the planning model state is updated to $\pstate_\text{next}$ in the planning model block (lines \ref{ln:planningStart}-\ref{ln:planningEnd}). 
We repeat this process until the planning goal has been reached.